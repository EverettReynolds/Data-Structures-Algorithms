Script started on Mon 09 Nov 2020 10:49:18 AM EST
]0;reynolds@cobra:~/C++/Prog3[?1034h[reynolds@cobra Prog3]$ cat -n zip.cpp
     1	#include <iostream>
     2	#include <fstream>
     3	#include <string>
     4	#include <algorithm>
     5	#include <cctype>
     6	#include "huffman.h"
     7	using namespace std;
     8	
     9	const int letterNum = 256; 
    10	const int lineLength = 80;
    11	
    12	
    13	void fileError(string fName);
    14	void formatError();
    15	void inputChecker(int argc, char *argv[]);
    16	void treeCreation(string flag, string fileName);
    17	void fileCreation(string fileName, int Letters[], HuffmanTree huff);
    18	void printHelpMessage();
    19	int main(int argc, char *argv[])
    20	{
    21	  
    22	  if(argc <= 1)
    23	  {
    24	    cout << " No input has been entered. Aborting. " << endl;
    25	  }
    26	  else
    27	  {
    28	    inputChecker(argc,argv);
    29	    
    30	  }
    31	  
    32	  return 0;
    33	}
    34	
    35	
    36	void inputChecker(int argc, char *argv[])
    37	{
    38	  string flag;
    39	  string fileName;
    40	  ifstream infile;
    41	  
    42	  if(argc == 2)
    43	  {
    44	    flag = argv[1];
    45	    if(flag == "--help")
    46	    {
    47	      printHelpMessage();
    48	    }
    49	    if(flag == "--t")
    50	    {
    51	      formatError();
    52	    }
    53	    else
    54	    {
    55	      
    56	      fileName = argv[1];
    57	      ifstream infile(fileName.c_str());
    58	      if(!infile)
    59	      {
    60	        fileError(fileName);
    61	      }
    62	      flag = "N/A";
    63	      infile.close();
    64	      treeCreation(flag,fileName);
    65	    }
    66	   
    67	  }
    68	  if(argc == 3 )
    69	  {
    70	    flag = argv[1];
    71	    if(flag == "--help")
    72	    {  
    73	       fileName = argv[2];
    74	       
    75	       ifstream infile(fileName.c_str());
    76	      if(!infile)
    77	      {
    78	        fileError(fileName);
    79	      }
    80	      printHelpMessage();
    81	    }
    82	    if(flag == "--t")
    83	    {
    84	      fileName = argv[2];
    85	       
    86	       ifstream infile(fileName.c_str());
    87	      if(!infile)
    88	      {
    89	        fileError(fileName);
    90	      }
    91	      infile.close();
    92	      treeCreation(flag,fileName);
    93	      
    94	    }
    95	    if(!infile)
    96	    {
    97	      fileName = argv[2];
    98	      fileError(fileName);
    99	    }
   100	  }
   101	  
   102	} 
   103	void treeCreation(string flag, string fileName)
   104	{
   105	  char ch,curr;
   106	  HuffmanTree huff;
   107	  int Letters [letterNum];
   108	  
   109		for (char ch = char(0);  ch <= char(126);  ch++)
   110	   {
   111		  Letters[ch] = 0;
   112	   }
   113	   ifstream infile(fileName.c_str());
   114	   
   115	   while(infile)
   116	   {
   117	     infile.get(curr);
   118	     Letters[curr]++;
   119	     
   120	   }
   121	   
   122	   for (char ch = char(0);  ch <= char(126);  ch++)
   123	   {
   124	     if(Letters[ch] != 0)
   125	     {
   126	       huff.insert(ch, Letters[ch]);
   127	     }
   128	   }
   129	   huff.build();
   130	   if(flag == "--t")
   131	   {
   132	     huff.PrintTable();
   133	     fileCreation(fileName,Letters,huff);
   134	   }
   135	   if(flag == "N/A")
   136	   {
   137	     fileCreation(fileName,Letters,huff);
   138	   }
   139	   if(flag != "N/A" && flag != "--t")
   140	   {
   141	     fileError(fileName);
   142	   }
   143	   
   144	   
   145	}
   146	
   147	void fileCreation(string fileName, int Letters[], HuffmanTree huff)
   148	{
   149	  int charNum;
   150	  double percent;
   151	  char character;
   152	  string encrypt;
   153	  float bits1;
   154	  float bits2;
   155	  ifstream infile(fileName.c_str());
   156	  string newFile = fileName + "m.zip";
   157	  ofstream outFile(newFile.c_str());
   158	  charNum = ((huff.numNodes() + 1)/2);
   159	  outFile << charNum << endl;
   160	  
   161	  for (char ch = char(0);  ch <= char(126);  ch++)
   162	  {
   163		  if  (Letters[ch] != 0)
   164	    {
   165	      outFile << int(ch) << " " << huff.GetCode(ch) << endl;
   166	    }
   167	  } 
   168	  infile.get(character);
   169	  while(infile)
   170	  {
   171	    bits2++;
   172	    encrypt = encrypt + huff.GetCode(character);
   173	    infile.get(character);
   174	  } 
   175	  bits1 = encrypt.length();
   176	  outFile << encrypt;
   177	  percent = ((1-(bits1/(bits2*8)))*100);
   178	  cout << "File Sucessfully Compressed to" << " " << bits1 << " " << "Bits ( " << percent << " % Less)." << endl;
   179	  
   180	  infile.close();
   181	  outFile.close(); 
   182	} 
   183	void fileError(string fName)
   184	{
   185	  cout << "Your Zip File " << fName << " does not exist. Aborting. " << endl;
   186	  exit(1);
   187	}
   188	
   189	void formatError()
   190	{
   191	  cout << " You Have Input an Invalid File Format." << endl;
   192	  cout << " Type `ZIP --help ` if you need more information. Aborting. " << endl;
   193	  exit(1);
   194	}
   195	
   196	void printHelpMessage()
   197	{
   198	  ifstream help;
   199	  string line;
   200	  help.open("help");
   201	  
   202	  while( getline(help,line))
   203	  {
   204	    cout << help << endl;
   205	  }
   206	  help.close();
   207	}
]0;reynolds@cobra:~/C++/Prog3[reynolds@cobra Prog3]$ cat huffman.h
#include <vector>
#include <string>
using namespace std;

struct HNode {
    char ch;
    int weight;
    int parent;
    int childType;
};

class HuffmanTree {
    public:
	HuffmanTree();				// constructor

	void insert(char ch, int weight);	// inserts a character and its associated weight
						// into a node of the Huffman tree

	bool inTree(char ch);			// returns a boolean value indicating whether
						// a given character is stored in the tree
		
	int GetFrequency(char ch);		// returns the weight of a given character

	
	void build();				// Builds the Huffman Tree;
	

	string GetCode(char ch);		// returns the compressed code of a given
						// character in the tree using recursion

	void PrintTable();			// displays the Huffman encoding table used in
						// the compression process
	
	int numNodes();				// returns the number of nodes currently in Huffman 
						// tree

    private:
	vector<HNode> nodes;
	int numChars;
	bool built;                             
	
	int lookUp(char ch);			// returns the index of a given character in tree
	int GetFrequency(int i);		// returns the weight at a given index
	string GetCode(int i);			// returns the compressed code of the character at 
						// a given index
};
]0;reynolds@cobra:~/C++/Prog3[reynolds@cobra Prog3]$ cat huffman.cpp
#include "huffman.h"
#include <iostream>
#include <queue>
using namespace std;

HuffmanTree:: HuffmanTree()
	: numChars(0), built(false) {}

void HuffmanTree:: insert(char ch, int weight) {
    HNode newNode = {ch, weight, -1, -1}; 
    built = false;
    nodes.push_back(newNode);
    numChars++;

}

bool HuffmanTree:: inTree(char ch) {

  return lookUp(ch) == ch;
  
}

int HuffmanTree:: GetFrequency(char ch) { //public

  return GetFrequency(lookUp(ch));
  
}

int HuffmanTree:: GetFrequency(int i) { //private
  return nodes[i].weight;
}

int HuffmanTree:: lookUp(char ch) {

  int index;
  
  
  for(int i = 0; i < numChars; i++)
  {
    if(nodes[i].ch == ch)
    {
      i = index;
      return index;
    }
  }
  return -1;
}

string HuffmanTree:: GetCode(char ch) { //public 

  GetCode(lookUp(ch));
  
}


string HuffmanTree:: GetCode(int i) { //private
  
  if(nodes[i].parent == 0)
  {
    return "";
  }
  else
  {
    return (GetCode(nodes[i].parent) + (char)(nodes[i].childType + '0'));
  }
}

void HuffmanTree:: PrintTable() {

  int madeNode = 1;
  cout << "\t ## ENCODING TABLE FOR ZIP FILE ## \n " << endl;
  cout << "\t Index\tChar\tWeight\tParent\tChildType " << endl;
  
  for(int i = 0; i < nodes.size(); i++)
  {
    if(nodes[i].ch == '\n')
    {
      cout << i << '\t' << "nl" << '\t' << nodes[i].weight << '\t' << nodes[i].parent << '\t' << nodes[i].childType << '\t' << endl;
    }
    if(nodes[i].ch == ' ')
    {
      cout << i << '\t' << "sp" << '\t' << nodes[i].weight << '\t' << nodes[i].parent << '\t' << nodes[i].childType << '\t' << endl;
    }
    if(nodes[i].ch == '\0')
    {
      if( nodes[i].childType == 2)
      {
        cout << i << '\t' << "T" << madeNode << "\t" << nodes[i].weight << "\t" <<  nodes[i].parent << "\t" << "N/A" << "\t" << endl;
        madeNode++;
      }
      else
      {
         cout << i << '\t' << "T" << madeNode << "\t" << nodes[i].weight << "\t" <<  nodes[i].parent << "\t" << nodes[i].childType << "\t" << endl;
         madeNode++;
      }
    }
    else
    {
      cout << i << "\t" << nodes[i].ch << "\t" << nodes[i].weight << "\t" << nodes[i].parent << "\t" << nodes[i].childType << "\t" << endl;
    }
  }
  
}

int HuffmanTree:: numNodes() {
  return numChars;
}

void HuffmanTree:: build() {
  
  int max = (2*numChars)-2;
  int first; // smallest value
  int second; // second smallest after first
  
  for( int i = 0; i < max; i++)
  {
    first = i;
    second = 0;
    
    if( second == first )
    {
      second++;
    }
    else if( nodes[second].parent != -1)
    {
      second++;
    }
    else if( nodes[i].parent == -1)
    {
      for(int j = 0; j < nodes.size(); j++)
      {
        if(nodes[j].parent == -1 && nodes[first].weight > nodes[j].weight)
        {
          first = j;
        }
      }
    }
    else
    {
      for(int k = 0; k < nodes.size(); k++)
      { 
        if(nodes[k].parent != -1 && k!= first)
        {
          second = k;
        }
        if(nodes[second].weight > nodes[k].weight)
        {
          second = k;
        }
        
      }
    }
    int totalWeight = nodes[first].weight  + nodes[second].weight;
    HNode newest = {'\0',totalWeight,-1,-1};
    nodes.push_back(newest);
    nodes[first].parent = nodes.size()-1;
    nodes[first].childType = 0;
    nodes[second].parent = nodes.size()-1;
    nodes[second].childType = 1;
  }
  nodes[nodes.size()-1].parent = 0;
  nodes[nodes.size()-1].childType = 2;
  built = true;



}
]0;reynolds@cobra:~/C++/Prog3[reynolds@cobra Prog3]$ cat huffman.cpp[2Ph-n zip.cppls[Kcd Prog3[2PC++ssh reynolds_ez@assemble.cs.mercer.edu[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[Cexit[Kc++ zip.cpp[7Ppeekc++ zip.cppls[Kclearssh reynolds_ez@assemble.cs.mercer.edu[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[Cc++ zip.cpp[K[6Plear++ zip.cpp[3Pd Prog3[2PC++++ zip.cpp[7Pexit[1Prxissh reynolds_ez@assemble.cs.mercer.edu[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[Ctop[Kvim unzipped./a.out sample4.zip[6Pc++ unzip.cpp[5Pvim helpcp unzip.cpp /scratch/csc245/reynolds/Prog3[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[Cvim help[Kc++ unzip.cpp./a.out sample4.zip[7Pvim unzippedtop[Kssh reynolds_ez@assemble.cs.mercer.edu[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[Crxi[Kexitc++ zip.cpp[5Pd C++Prog3++ zip.cpp[6Plear++ zip.cppssh reynolds_ez@assemble.cs.mercer.edu[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[Cclear[K[3Plsc++ zip.cpp[7Ppeekc++ zip.cpp[7Pexitssh reynolds_ez@assemble.cs.mercer.edu[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[Ccd C++[KProg3ls[Kcat -n zip.cpp[1Phuffman.hcpp[Kc++ zi[p[K[Kp.cpp hum[Kffman.o
]0;reynolds@cobra:~/C++/Prog3[reynolds@cobra Prog3]$ mv a.out myZI[Kip
]0;reynolds@cobra:~/C++/Prog3[reynolds@cobra Prog3]$ c++ unzip.cpp
]0;reynolds@cobra:~/C++/Prog3[reynolds@cobra Prog3]$  a.out[K[K[K[K[K[Kmv a.out myUnzip
]0;reynolds@cobra:~/C++/Prog3[reynolds@cobra Prog3]$ cat sample4
MERCER TENNIS
]0;reynolds@cobra:~/C++/Prog3[reynolds@cobra Prog3]$ cat sample4mv a.out myUnzip[3Pc++ unzip.cppmv a.out myZipc++ zip.cpp huffman.o[6Pat huffman.cpp[2Phcpp++ zip.cpp huffman.o[7Pmv a.out myZip[1Pc++ unzip.cppmv a.out myUnzip[5Pcat sample4[K./a.out myZip[K[K[K[K[Ksample4
bash: ./a.out: No such file or directory
]0;reynolds@cobra:~/C++/Prog3[reynolds@cobra Prog3]$ ./a.out sample4[C[1P sample4[1P sample4[1P sample4[1P sample4[1P sample4Z sample4I sample4P sample4[1P sample4[1P sample4[1P sample4m sample4y sample4Z sample4I sample4P sample4
bash: ./myZIP: No such file or directory
]0;reynolds@cobra:~/C++/Prog3[reynolds@cobra Prog3]$ ./myZIP sample4a.out[C[C[C[C[C[C[C[C[4Pca[C[C[C[C[C[C[C[C[Cmv a.out myUnzip[3Pc++ unzip.cppmv a.out myZip[1Pc++ unzip.cppmv a.out myZipc++ zip.cpp huffman.o[6Pat huffman.cpp[2Phcpp++ zip.cpp huffman.o[6Pat huffman.cpp[2Phcpp++ zip.cpp huffman.o[7Pmv a.out myZip[1Pc++ unzip.cppmv a.out myZip[1Pc++ unzip.cppmv a.out myUnzip[5Pcat sample4[4@./a.ou[C[C[C[C[C[C[C[C[CmyZIP[C[C[C[C[C[C[C[C[K./myUnzup[K[Kip sample4.zip
File Has Been Sucessfully Inflated
]0;reynolds@cobra:~/C++/Prog3[reynolds@cobra Prog3]$ ./myUnzip sample4.zip[C[K[K[K[K[C[1P[1P[1P[1@Z[C[1@i[1P
Segmentation fault (core dumped)
]0;reynolds@cobra:~/C++/Prog3[reynolds@cobra Prog3]$ exit
exit

Script done on Mon 09 Nov 2020 10:54:45 AM EST
