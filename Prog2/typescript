Script started on Wed 07 Oct 2020 11:26:01 PM EDT
]0;reynolds@cobra:~/C++/Prog2[?1034h[reynolds@cobra Prog2]$ cat testBet.cpp
#include <stack>
#include <bits/stdc++.h>
#include<iostream> // add continuous loop do-while to cycle through program
#include "bet.h"
using namespace std;

void printMenu(char choice);
void makeEmpty(BET t);
void Prefix(BET& t);
void Infix(BET t);
void Postfix(BET t);
void expressOutput(BET t); // Build another tree will be here
int precedence(char o);


int main()
{
  char choice;
  
  BET t = BET();
  
  do
  {
  
    printMenu(choice);
    cin >> choice;
    switch (toupper(choice))
    {
      case 'A': Prefix(t);  break;
      case 'B': Infix(t); break;
      case 'C': Postfix(t); break;
      case 'Y': printMenu(choice); cin >> choice; break;
      case 'N':  break;
      default : cout << "\tError. Enter Valid Input." << endl;
    }
    
  }while(toupper(choice) != 'N');
  

  cout << "Program Now Deconstructing Tree and Exiting." <<endl;
  return 0;
}

void printMenu(char choice)
{
  cout<< "      &&&&&&&&&&&          Building Binary Trees and Expressions     &&&&&&&&&&&               " << endl;
  cout<< " A) Prefix                 B) Infix                               C) Postfix" << endl;
  cout<< "Your Expression Type ==> ";
  
   
}

void Prefix(BET& t)
{
  string equation;
  char token;
  cout<< "Enter Your Equation ";
  cin >> equation;
  
  for(int i  = equation.length(); i >= 0; i--)
  {
    if(equation[i] == '+' || equation[i] == '-' || equation[i] == '/' || equation[i] == '*')
    {
      t.insertPrefixOperator(equation[i]);
    }
    else
    {
      t.insertOperand(equation[i]);
    }
  
  }
  
  expressOutput(t);
  
  
}

void Infix(BET t)
{
  string equation;
  string translation;
  char token;
  stack <char> s;
  s.push('&');
  cout<< "Enter Your Equation ";
  cin >> equation;
  for(int i  = 0; i < equation.length(); i++)
  {
    if((equation[i] >= 'A' && equation[i] <= 'Z') || (equation[i] >= 'a' && equation[i] <= 'z'))
    {
      translation = translation + equation[i];
    }
    
    else if(equation[i] == '(')
    {
      s.push('(');
    }
    
    else if(equation[i] == ')')
    {
    
      while(s.top() != '&' && s.top() != '(')
      {
        char o = s.top();
        s.pop();
        translation = translation + o;
      }
      
      if(equation[i] == '(')
      {
        char o = s.top();
        s.pop();
      }
      
    }
  
    else
    {
      while(s.top() != '&' && precedence(equation[i]) <= precedence(s.top()))
      {
        char o = s.top();
        s.pop();
        translation = translation + o;
        
      }
      s.push(equation[i]);
    }
  }
  
  while(s.top() != '&')
  {
    char o = s.top();
    s.pop();
    translation = translation + o;
  }
  for(int i  = 0; i < translation.length(); i++)
  {
    if(translation[i] == '+' || translation[i] == '-' || translation[i] == '/' || translation[i] == '*')
    {
      t.insertPostfixOperator(translation[i]);
    }
    else
    {
      t.insertOperand(translation[i]);
    }
  
  }
  
  expressOutput(t);
  
}

void Postfix(BET t)
{
  string equation;
  char token;
  cout<< "Enter Your Equation ";
  cin >> equation;
  
  for(int i  = 0; i < equation.length(); i++)
  {
    if(equation[i] == '+' || equation[i] == '-' || equation[i] == '/' || equation[i] == '*')
    {
      t.insertPostfixOperator(equation[i]);
    }
    else
    {
      t.insertOperand(equation[i]);
    }
  
  }
  
  expressOutput(t);
  
}



void expressOutput(BET t) // call this after BET is built
{
  cout << "Prefix Expression Produced From This Tree: " << endl;
  t.preorder();
  cout << "Infix Expression Produced From This Tree: " << endl;
  t.inorder();
  cout << "Postfix Expression Produced From This Tree: " << endl;
  t.postorder();
  cout << "Build Another Tree? Type 'Y' or 'N' to continue or leave respectively." << endl;
  
}

int precedence(char o)
{

  if(o == '*' || o == '/') 
  {
    return 2; 
  }
  else if(o == '+' || o == '-') 
  {
    return 1; 
  }
  else
  {
    return -1;
  }
}





]0;reynolds@cobra:~/C++/Prog2[reynolds@cobra Prog2]$ cat bet.cpp
#include <stack>
#include <bits/stdc++.h>
#include <cstddef> 
#include "bet.h"
using namespace std;

BET::BET  ()
{
  BETPtr root; // root of tree
  stack <BETPtr> s; // a stack
}

BET::~BET  ()
{

}

bool BET::isEmpty() const
{
  if(root == NULL)
  {
    return true;
  }
  else
  {
  return false;
  }
}

void BET::makeEmpty() // public
{
  makeEmpty(root);
}

void BET::makeEmpty( BETPtr& t ) const //private
{
  delete root;
}

void BET::insertPrefixOperator (char token) // prefix expression tree
{
  BETPtr newBet = new BinaryNode;
  newBet -> info.whichType = OPERATOR;
  newBet -> info.theContent.opsymbol = token;
  newBet -> left = s.top();
  s.pop();
  newBet -> right = s.top();
  s.pop();
  s.push(newBet);
  root = newBet;
}

void BET::insertPostfixOperator (char token) //postfix expression tree
{
  BETPtr newBet = new BinaryNode;
  newBet -> info.whichType = OPERATOR;
  newBet -> info.theContent.opsymbol = token;
  newBet -> right = s.top();
  s.pop();
  newBet -> left = s.top();
  s.pop();
  s.push(newBet);
  root = newBet;
  
}

void BET::insertOperand (char token) // infix expression tree
{

  BETPtr newBet = new BinaryNode;
  newBet -> info.whichType = OPERAND;
  newBet -> info.theContent.variable = token;
  newBet -> right = NULL;
  newBet -> left = NULL;
  s.push(newBet);
  
}

void BET::preorder() const //PUBLIC //printing trees
{
  
  if( isEmpty())
  {
    cout << "The Tree is Empty.";
  }
  else
  {
    preorder(root);
  }
  cout << endl;
  
}

void BET::preorder( BETPtr t ) const //PRIVATE
{
  if( t != NULL)
  {
    if((t->info.whichType) == OPERAND)
    {
      cout << t->info.theContent.variable << " ";
    }
    else
    {
       cout << t->info.theContent.opsymbol << " ";
    }
    
    preorder(t->left);
    preorder(t->right);
    
  }
}

void BET::inorder() const //PUBLIC //printing trees
{
  if( isEmpty())
  {
    cout << "The Tree is Empty.";
  }
  else
  {
    inorder(root);
  }
  cout << endl;
}

void BET::inorder( BETPtr t ) const //PRIVATE
{
  if( t!= NULL)
  {
    if(t-> left != NULL)
    {
      cout << "(";
    }
    inorder(t->left);
    if((t->info.whichType) == OPERAND)
    {
      cout << t->info.theContent.variable << " ";
    }
    else
    {
       cout << t->info.theContent.opsymbol << " ";
    }
    inorder(t->right);
    if(t-> right != NULL)
    {
      cout << ")";
    }
  }
}

void BET::postorder() const //PUBLIC //printing trees
{
  
  if( isEmpty())
  {
    cout << "The Tree is Empty.";
  }
  else
  {
    postorder(root);
  }
  cout << endl;
  
}

void BET::postorder( BETPtr t ) const //PRIVATE
{
  if( t != NULL)
  {
    
    postorder(t->left);
    postorder(t->right);
    
    if((t->info.whichType) == OPERAND)
    {
      cout << t->info.theContent.variable << " ";
    }
    else
    {
       cout << t->info.theContent.opsymbol << " ";
    }
  }
}








]0;reynolds@cobra:~/C++/Prog2[reynolds@cobra Prog2]$ cat bet.cpptestBet.cppssh reynolds_ez@assemble.cs.mercer.edu[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[24Pc++ -c bet.cpp[6Pd Prog2[2PC==++++ -c bet.cpplear[K++ -c bet.cpplear[K++ -c bet.cpplear[K++ -c bet.cpplear[K++ -c bet.cpplear[K++ -c bet.cpplear[K++ -c bet.cpptestBet.cpp bet.o[13Pd Prog2++ testBet.cpp bet.o
]0;reynolds@cobra:~/C++/Prog2[reynolds@cobra Prog2]$ ./a/[K.out
      &&&&&&&&&&&          Building Binary Trees and Expressions     &&&&&&&&&&&               
 A) Prefix                 B) Infix                               C) Postfix
Your Expression Type ==> A
Enter Your Equation -*1+238
Prefix Expression Produced From This Tree: 
- * 1 + 2 3 8 
Infix Expression Produced From This Tree: 
((1 * (2 + 3 ))- 8 )
Postfix Expression Produced From This Tree: 
1 2 3 + * 8 - 
Build Another Tree? Type 'Y' or 'N' to continue or leave respectively.
      &&&&&&&&&&&          Building Binary Trees and Expressions     &&&&&&&&&&&               
 A) Prefix                 B) Infix                               C) Postfix
Your Expression Type ==> Y
      &&&&&&&&&&&          Building Binary Trees and Expressions     &&&&&&&&&&&               
 A) Prefix                 B) Infix                               C) Postfix
Your Expression Type ==> C
      &&&&&&&&&&&          Building Binary Trees and Expressions     &&&&&&&&&&&               
 A) Prefix                 B) Infix                               C) Postfix
Your Expression Type ==> C
Enter Your Equation 123+*8-
Prefix Expression Produced From This Tree: 
- * 1 + 2 3 8 
Infix Expression Produced From This Tree: 
((1 * (2 + 3 ))- 8 )
Postfix Expression Produced From This Tree: 
1 2 3 + * 8 - 
Build Another Tree? Type 'Y' or 'N' to continue or leave respectively.
      &&&&&&&&&&&          Building Binary Trees and Expressions     &&&&&&&&&&&               
 A) Prefix                 B) Infix                               C) Postfix
Your Expression Type ==> B
Enter Your Equation ((1*(2+3))-8)
Prefix Expression Produced From This Tree: 
- 2 3 
Infix Expression Produced From This Tree: 
(2 - 3 )
Postfix Expression Produced From This Tree: 
2 3 - 
Build Another Tree? Type 'Y' or 'N' to continue or leave respectively.
      &&&&&&&&&&&          Building Binary Trees and Expressions     &&&&&&&&&&&               
 A) Prefix                 B) Infix                               C) Postfix
Your Expression Type ==> n
Program Now Deconstructing Tree and Exiting.
]0;reynolds@cobra:~/C++/Prog2[reynolds@cobra Prog2]$ exit[K[K[K[Kexit
exit

Script done on Wed 07 Oct 2020 11:29:25 PM EDT
